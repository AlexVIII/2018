## Servlet

[1. Что такое сервлет?](#1-Что-такое-сервлет)

[2. Какова структура веб-проекта?](#2-Какова-структура-веб-проекта)

[3. Что такое контейнер сервлетов?](#3-Что-такое-контейнер-сервлетов)

[4. Каковы задачи, функциональность контейнера сервлетов?](#4-Каковы-задачи-функциональность-контейнера-сервлетов)

[5. Что вы знаете о сервлет фильтрах?](#5-Что-вы-знаете-о-сервлет-фильтрах)

[6. Зачем нужны слушатели в сервлетах?](#6-Зачем-нужны-слушатели-в-сервлетах)

[7. Когда вы будете использовать фильтры сервлетов, а когда слушатели?](#7-Когда-вы-будете-использовать-фильтры-сервлетов-а-когда-слушатели)

[8. Как обработать исключения, выброшенные другим сервлетом в приложении?](#8-Как-обработать-исключения-выброшенные-другим-сервлетом-в-приложении)

[9. Что такое дескриптор развертывания?](#9-Что-такое-дескриптор-развертывания)

[10. Как реализовать запуск сервлета с запуском приложения?](#10-Как-реализовать-запуск-сервлета-с-запуском-приложения)

[11. Что представляет собой объект ServletConfig?](#11-Что-представляет-собой-объект-ServletConfig)

[12. Что представляет собой объект ServletContext?](#12-Что-представляет-собой-объект-ServletContext)

[13. В чем отличия ServletContext и ServletConfig?](#13-В-чем-отличия-ServletContext-и-ServletConfig)

[14. Что такое Request Dispatcher?](#14-Что-такое-Request-Dispatcher)

[15. Как можно создать блокировку (deadlock) в сервлете?](#15-Как-можно-создать-блокировку-(deadlock)-в-сервлете)

[16. Как получить адрес сервлета на сервере?](#16-Как-получить-адрес-сервлета-на-сервере)

[17. Как получить информацию о сервере из сервлета?](#17-Как-получить-информацию-о-сервере-из-сервлета)

[18. Как получить ip адрес клиента на сервере?](#18-Как-получить-ip-адрес-клиента-на-сервере)

[19. Что вы знаете о классах обертках (wrapper) для сервлетов?](#19-Что-вы-знаете-о-классах-обертках-(wrapper)-для-сервлетов)

[20. Каков жизненный цикл сервлета и когда какие методы вызываются?](#20-Каков-жизненный-цикл-сервлета-и-когда-какие-методы-вызываются)

[21. Какие методы необходимо определить при создании сервлетов?](#21-Какие-методы-необходимо-определить-при-создании-сервлетов)

[22. В каком случае вы будете переопределять метод service()?](#22-В-каком-случае-вы-будете-переопределять-метод-service())

[23. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?](#23-Есть-ли-смысл-определить-конструктор-для-сервлета-как-лучше-инициализировать-данные)

[24. В чем отличия GenericServlet и HttpServlet?](#24-В-чем-отличия-GenericServlet-и-HttpServlet)

[25. Как вызвать из сервлета другой сервлет этого же и другого приложения?](#25-Как-вызвать-из-сервлета-другой-сервлет-этого-же-и-другого-приложения)

[26. Что вы знаете и в чем отличия методов forward() и sendRedirect()?](#26-Что-вы-знаете-и-в-чем-отличия-методов-forward()-и-sendRedirect())

[27. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?](#27-Стоит-ли-волноваться-о-“многопоточной-безопасности”-работая-с-сервлетами)

[28. В чем отличие между веб сервером и сервером приложений?](#28-В-чем-отличие-между-веб-сервером-и-сервером-приложений)

[29. Какой метод HTTP не является неизменяемым?](#29-Какой-метод-HTTP-не-является-неизменяемым)

[30. Почему HttpServlet класс объявлен как абстрактный?](#30-Почему-HttpServlet-класс-объявлен-как-абстрактный)

[31. В чем разница между методами GET и POST?](#31-В-чем-разница-между-методами-GET-и-POST)

[32. Что такое MIME-тип?](#32-Что-такое-MIME-тип)

[33. Назовите преимущества Servlet над CGI?](#33-Назовите-преимущества-Servlet-над-CGI)

[34. Каковы наиболее распространенные задачи выполняются в Servlet контейнере?](#34-Каковы-наиболее-распространенные-задачи-выполняются-в-Servlet-контейнере)

[35. В чем разница между PrintWriter и ServletOutputStream?](#35-В-чем-разница-между-PrintWriter-и-ServletOutputStream)

[36. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?](#36-Можем-ли-мы-получить-PrintWriter-и-ServletOutputStream-одновременно-в-сервлете)

[37. Расскажите о интерфейсе SingleThreadModel.](#37-Расскажите-о-интерфейсе-SingleThreadModel)

[38. Какие существуют атрибуты у сервлетов и какая сфера их применения?](#38-Какие-существуют-атрибуты-у-сервлетов-и-какая-сфера-их-применения)

[39. Почему необходимо переопределить только init() метод без аргументов?](#39-Почему-необходимо-переопределить-только-init()-метод-без-аргументов)

[40. Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode() и decode()?](#40-Что-означает-URL-encoding-Зачем-нужны-методы-javanetURLEncoderencode()-и-decode())

[41. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?](#41-Зачем-нужны-и-чем-отличаются-методы-encodeUrl()-и-encodeRedirectUrl())

[42. Какие различные методы управления сессией в сервлетах вы знаете?](#42-Какие-различные-методы-управления-сессией-в-сервлетах-вы-знаете)

[43. Что означает URL Rewriting?](#43-Что-означает-URL-Rewriting)

[44. Как применяются Cookies в сервлетах?](#44-Как-применяются-Cookies-в-сервлетах)

[45. Как уведомить объект в сессии, что сессия недействительна или закончилась?](#45-Как-уведомить-объект-в-сессии-что-сессия-недействительна-или-закончилась)

[46. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?](#46-Какой-существует-эффективный-способ-удостоверится-что-все-сервлеты-доступны-только-для-пользователя-с-валидной-сессией)

[47. Как мы можем обеспечить transport layer security для нашего веб приложения?](#47-Как-мы-можем-обеспечить-transport-layer-security-для-нашего-веб-приложения)

[48. Как организовать подключение к базе данных и обеспечить логирование log4j в сервлете?](#48-Как-организовать-подключение-к-базе-данных-и-обеспечить-логирование-log4j-в-сервлете)

[49. Какие важные особенности существуют в Servlet 3?](#49-Какие-важные-особенности-существуют-в-Servlet-3)

[50. Каковы различные способы аутентификации сервлета?](#50-Каковы-различные-способы-аутентификации-сервлета)

[51. Написать сервлет, реализующий загрузку файла на сервер?](#51-Написать-сервлет-реализующий-загрузку-файла-на-сервер)

[52. ](#52-)

## 1. Что такое сервлет?

Сервлет является интерфейсом Java, реализация которого расширяет функциональные возможности сервера. 
Сервлет взаимодействует с клиентами посредством принципа запрос-ответ.
Хотя сервлеты могут обслуживать любые запросы, они обычно используются для расширения веб-серверов. 
Для таких приложений технология `Java Servlet` определяет HTTP-специфичные сервлет классы. 
Пакеты `javax.servlet` и `javax.servlet.http` обеспечивают интерфейсы и классы для создания сервлетов.

Основные методы сервлета:

+ `public void init(ServletConfig config) throws ServletException` запускается сразу после загрузки сервлета в память;
+ `public ServletConfig getServletConfig()` возвращает ссылку на объект, 
который предоставляет доступ к информации о конфигурации сервлета;
+ `public String getServletInfo()` возвращает строку, содержащую информацию о сервлете, например: автор и версия сервлета;
+ `public void service(ServletRequest request, ServletResponse response) throws ServletException, 
java.io.IOException` вызывается для обработки каждого запроса;
+ `public void destroy()` выполняется перед выгрузкой сервлета из памяти.

https://docs.oracle.com/javaee/7/api/javax/servlet/Servlet.html

https://docs.oracle.com/javaee/7/tutorial/servlets001.htm#BNAFE

[к оглавлению](#Servlet)

## 2. Какова структура веб проекта?

| Path | Description |
| --- | --- |
| src/main/java| Application/Library sources |
| src/main/resources| Application/Library resources |
| src/main/filters| Resource filter files |
| src/main/webapp| Web application sources |
| src/test/java| Test sources |
| src/test/resources| Test resources |
| src/test/filters| Test resource filter files |
| src/it| Integration Tests (primarily for plugins) |
| src/assembly| Assembly descriptors |
| src/site| Site |
| LICENSE.txt| Project’s license |
| NOTICE.txt| Notices and attributions required by libraries that the project depends on |
| README.txt| Project’s readme 

http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html

[к оглавлению](#Servlet)

## 3. Что такое контейнер сервлетов?

**Контейнер сервлетов** — программа, представляющая собой сервер, который занимается системной поддержкой сервлетов 
и обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях.

Известные реализации: 
+ Apache Tomcat
+ Jetty
+ JBoss
+ WildFly
+ GlassFish
+ IBM WebSphere
+ Oracle Weblogic

[к оглавлению](#Servlet)

## 4. Каковы задачи, функциональность контейнера сервлетов?

Контейнер сервлетов может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого 
веб-сервера, например Apache, или интегрироваться в Java EE сервер приложений.

Обеспечивает обмен данными между сервлетом и клиентами, берёт на себя выполнение таких функций, 
как создание программной среды для функционирующего сервлета, идентификацию и авторизацию клиентов, организацию сессии 
для каждого из них.

[к оглавлению](#Servlet)

## 5. Что вы знаете о сервлет фильтрах?

**Сервлетный фильтр** - это Java-код, пригодный для повторного использования и позволяющий преобразовать содержание 
HTTP-запросов, HTTP-ответов и информацию, содержащуюся в заголовках HTML. Сервлетный фильтр занимается предварительной 
обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета.

Сервлетные фильтры могут:

+ перехватывать инициацию сервлета прежде, чем сервлет будет инициирован;
+ определить содержание запроса прежде, чем сервлет будет инициирован;
+ модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;
+ модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ;
+ перехватывать инициацию сервлета после обращения к сервлету.

Сервлетный фильтр может быть конфигурирован так, что он будет работать с одним сервлетом или группой сервлетов. 
Основой для формирования фильтров служит интерфейс `javax.servlet.Filter`, который реализует три метода:

+ `void init(FilterConfig config) throws ServletException`;
+ `void destroy()`;
+ `void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException`;

Метод `init()` вызывается прежде, чем фильтр начинает работать,и настраивает конфигурационный объект фильтра. 
Метод `doFilter()` выполняет непосредственно работу фильтра. Таким образом, сервер вызывает `init()` один раз, 
чтобы запустить фильтр в работу, а затем вызывает `doFilter()` столько раз, сколько запросов будет сделано 
непосредственно к данному фильтру. После того, как фильтр заканчивает свою работу, вызывается метод `destroy()`.

Интерфейс `FilterConfig` содержит метод для получения имени фильтра, его параметров инициации и контекста активного 
в данный момент сервлета. С помощью своего метода `doFilter()` каждый фильтр получает текущий запрос `request` и 
ответ `response`, а также `FilterChain`, содержащий список фильтров, предназначенных для обработки. 
В `doFilter()` фильтр может делать с запросом и ответом всё, что ему захочется - собирать данные или упаковывать объекты 
для придания им нового поведения. Затем фильтр вызывает `chain.doFilter()`, чтобы передать управление следующему фильтру. 
После возвращения этого вызова фильтр может по окончании работы своего метода `doFilter()` выполнить дополнительную работу 
над полученным ответом. К примеру, сохранить регистрационную информацию об этом ответе.

После того, как класс-фильтр откомпилирован, его необходимо установить в контейнер и _«приписать» (map)_ к одному или 
нескольким сервлетам. Объявление и подключение фильтра отмечается в дескрипторе развёртывания `web.xml` внутри 
элементов <filter> и <filter-mapping>. 
Для подключение фильтра к сервлету необходимо использовать вложенные элементы <filter-name> и <servlet-name>.

> Объявление класс-фильтра `FilterConnect` с именем `FilterName`:

```xml
  <filter>
        <filter-name>FilterName</filter-name>
        <filter-class>FilterConnect</filter-class>
        <init-param>
                <!--- фильтр имеет параметр инициализации `active`, которому присваивается значение `true`. -->
                <param-name>active</param-name>
                <param-value>true</param-true>
        </init-param>
  </filter>
```

> Подключение фильтра `FilterName` к сервлету `ServletName`:

```xml
  <filter-mapping>
        <filter-name>FilterName</filter-name>
        <servlet-name>ServletName</servlet-name>
  </filter-mapping>
```
Для связи фильтра со страницами HTML или группой сервлетов необходимо использовать тег `<url-pattern>`:

> Подключение фильтра `FilterName` ко всем вызовам .html страниц

```xml
  <filter-mapping>
          <filter-name>FilterName</filter-name>
          <url-pattern>*.html</url-pattern>
  </filter-mapping>
```

Порядок, в котором контейнер строит цепочку фильтров для запроса определяется следующими правилами:

+ цепочка, определяемая `<url-pattern>`, выстраивается в том порядке, в котором встречаются соответствующие описания 
фильтров в `web.xml`;
+ последовательность сервлетов, определенных с помощью `<servlet-name>`, также выполняется в той последовательности, 
в какой эти элементы встречаются в дескрипторе развёртывания `web.xml`.

https://www.journaldev.com/1933/java-servlet-filter-example-tutorial

[к оглавлению](#Servlet)

## 6. Зачем нужны слушатели в сервлетах?

__Listener (слушатель)__ работает как триггер, выполняя определённые действия при наступлении какого-либо события 
в жизненном цикле сервлета.

Слушатели, разделённые по области видимости (scope):

+ _Request_:
    + `ServletRequestListener` используется для того, чтобы поймать момент создания и уничтожения запроса;
    + `ServletRequestAttributeListener` используется для прослушивании событий происходящих с атрибутами запроса.
+ _Context_:
    + `ServletContextListener` позволяет поймать момент, когда контекст инициализируется либо уничтожается;
    + `ServletContextAttributeListener` используется для прослушивании событий происходящих с атрибутами в контексте.
+ _Session_:
    + `HttpSessionListener` позволяет поймать момент создания и уничтожения сессии;
    + `HttpSessionAttributeListener` используется при прослушивании событий происходящих с атрибутами в сессии;
    + `HttpSessionActivationListener` используется в случае, если происходит миграция сессии между различными JVM в 
    распределённых приложениях;
    + `HttpSessionBindingListener` так же используется для прослушивания событий происходящих с атрибутами в сессии. 
    
    Разница между `HttpSessionAttributeListener` и `HttpSessionBindingListener` слушателями: 
    + `HttpSessionAttributeListener` декларируется в `web.xml`, экземпляр класса создается контейнером автоматически 
    в единственном числе и применяется ко всем сессиям; 
    + для `HttpSessionBindingListener` экземпляр класса должен быть создан и закреплён за определённой сессией «вручную», 
    количество экземпляров также регулируется самостоятельно.

Подключение слушателей:

```xml
<web-app>
    ...
    <listener>
        <listener-class>xyz.company.ExampleListener</listener-class>
    </listener>
    ...
</web-app>
```

`HttpSessionBindingListener` подключается в качестве атрибута непосредственно в сессию, т.е., чтобы его подключить необходимо:
+ создать экземпляр класса реализующего этот интерфейс;
+ положить созданный экземпляр в сессию при помощи `setAttribute(String, Object)`.

[к оглавлению](#Servlet)

## 7. Когда вы будете использовать фильтры сервлетов, а когда слушатели?

Следует использовать фильтры, если необходимо обрабатывать входящие или исходящие данные 
(например: для аутентификации, преобразования формата, компрессии, шифрования и т.д.), 
в случае, когда необходимо реагировать на события - лучше применять слушателей.

http://www.journaldev.com/1945/servlet-listener-example-servletcontextlistener-httpsessionlistener-and-servletrequestlistener

[к оглавлению](#Servlet)

## 8. Как обработать исключения, выброшенные другим сервлетом в приложении?

Когда приложение выбрасывет исключение контейнер сервлетов обрабатывает его и создаёт ответ в формате HTML.
(т.е. контейнер создаст HTTP response, т.к. браузер понимает только HTTP)
Это аналогично тому что происходит при кодах ошибок вроде 404, 403 и т.д.

В дополнении к этому существует возможность написания собственных сервлетов для обработки исключений и ошибок 
с указанием их в дескрипторе развертывания:

```xml
<error-page>
    <error-code>404</error-code>
    <location>/AppExceptionHandler</location>
</error-page>
<error-page>
    <exception-type>javax.servlet.ServletException</exception-type>
    <location>/AppExceptionHandler</location>
</error-page>
```

Основная задача таких сервлетов - обработать ошибку/исключение и сформировать понятный HTTP ответ пользователю. 
Например, предоставить ссылку на главную страницу или же описание некоторых деталей об ошибке.

http://www.journaldev.com/1973/servlet-exception-and-error-handling-example-tutorial

[к оглавлению](#Servlet)

## 9. Что такое дескриптор развертывания?

**Дескриптор развертывания** — это конфигурационный файл артефакта, который будет развернут в контейнере сервлетов. 
В спецификации Java Platform, Enterprise Edition дескриптор развертывания описывает то, как компонент, модуль или 
приложение (такое, как веб-приложение или приложение предприятия) должно быть развернуто.

Этот конфигурационный файл указывает параметры развертывания для модуля или приложения с определенными настройками, 
параметры безопасности и описывает конкретные требования к конфигурации. Для синтаксиса файлов дескриптора 
развертывания используется язык XML.

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<web-app xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
    version="2.4">
    
    <display-name>Display name.</display-name>
    <description>Description text.</description>
    
    <servlet>
        <servlet-name>ExampleServlet</servlet-name>
        <servlet-class>xyz.company.ExampleServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
        <init-param>
            <param-name>configuration</param-name>
            <param-value>default</param-value>
        </init-param>       
    </servlet>
    
    <servlet-mapping>
        <servlet-name>ExampleServlet</servlet-name>
        <url-pattern>/example</url-pattern>
    </servlet-mapping>
    
    <servlet>
        <servlet-name>ExampleJSP</servlet-name>
        <jsp-file>/sample/Example.jsp</jsp-file>
    </servlet>
    
    <context-param>
        <param-name>myParam</param-name>
        <param-value>the value</param-value>
    </context-param>
</web-app>
```

Для веб-приложений дескриптор развертывания должен называться `web.xml` и находиться в директории `WEB-INF`, в корне 
веб-приложения. Этот файл является стандартным дескриптором развертывания, определенным в спецификации. 
Также есть и другие типы дескрипторов, такие, как файл дескриптора развертывания `sun-web.xml`, содержащий специфичные 
для _Sun GlassFish Enterprise Server_ данные для развертывания именно для этого сервера приложений или 
файл `application.xml` в директории `META-INF` для приложений _J2EE_.

Настройка и описание web.xml в приложении с Spring и JSF
http://javastudy.ru/jsf-2/description-settings-web-xml-with-spring

[к оглавлению](#Servlet)

## 10. Как реализовать запуск сервлета с запуском приложения?

Контейнер сервлетов обычно загружает сервлет по первому запросу клиента.

Если необходимо загрузить сервлет прямо на старте приложения (например если загрузка сервлета происходит длительное время) 
следует использовать элемент `<load-on-startup>` в дескрипторе или аннотацию `@loadOnStartup` в коде сервлета, 
что будет указывать на необходимость загрузки сервлета при запуске.

Значение должно быть целочисленное `int`. Если значение отрицательное, то сервлет будет загружен при запросе клиента. 
В противном случае (0 и далее) - загрузится на старте приложения. 
Чем число меньше, тем раньше в очереди на загрузку окажется сервлет.

```xml
<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
```

[к оглавлению](#Servlet)

## 11. Что представляет собой объект ServletConfig?

Интерфейс `javax.servlet.ServletConfig` используется для передачи сервлету конфигурационной информации. 
Каждый сервлет имеет свой собственный экземпляр объекта `ServletConfig`, создаваемый контейнером сервлетов.

Для установки параметров конфигурации используются параметры `init-param` в `web.xml`:

```xml
<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <init-param>
        <param-name>exampleParameter</param-name>
        <param-value>parameterValue</param-value>
    </init-param>
</servlet>
```

или аннотации `@WebInitParam`:

```java
@WebServlet(
    urlPatterns = "/example",
    initParams = {
        @WebInitParam(name = "exampleParameter", value = "parameterValue")
    }
)
public class ExampleServlet extends HttpServlet {
    //...
}
```

Для получения `ServletConfig` сервлета используется метод `getServletConfig()`.

[к оглавлению](#Servlet)

## 12. Что представляет собой объект ServletContext?

Уникальный (в рамках веб-приложения) объект `ServletContext` реализует интерфейс `javax.servlet.ServletContext` и 
предоставляет сервлетам доступ к параметрам этого веб-приложения. Для предоставления доступа используется элемент 
`<context-param>` в `web.xml`:

```xml
<web-app>
    ...
    <context-param>
        <param-name>exampleParameter</param-name>
        <param-value>parameterValue</param-value>
    </context-param>
    ...
</web-app>
```

Объект `ServletContext` можно получить с помощью метода `getServletContext()` у интерфейса `ServletConfig`. 
Контейнеры сервлетов так же могут предоставлять контекстные объекты, уникальные для группы сервлетов. 
Каждая из групп будет связана со своим набором URL-путей хоста. В спецификации Servlet 3 `ServletContext` был расширен 
и теперь предоставляет возможности программного добавления слушателей и фильтров в приложение. 

Так же у этого интерфейса имеется множество полезных методов таких как `getServerInfo()`, `getMimeType()`, 
`getResourceAsStream()` и т.д.

[к оглавлению](#Servlet)

## 13. В чем отличия ServletContext и ServletConfig?

+ `ServletConfig` уникален для сервлета, а `ServletContext` - для приложения;
+ `ServletConfig` используется для предоставления параметров инициализации конкретному сервлету, 
а `ServletContext` для предоставления параметров инициализации для всех сервлетов приложения;
+ для `ServletConfig` возможности модифицировать атрибуты отсутствуют, атрибуты в объекте `ServletContext` можно изменять.

[к оглавлению](#Servlet)

## 14. Что такое Request Dispatcher?

Интерфейс `RequestDispatcher` используется для передачи запроса другому ресурсу, при этом существует возможность 
добавления данных полученных из этого ресурса к собственному ответу сервлета. 
Так же этот интерфейс используется для внутренней коммуникации между сервлетами в одном контексте.

В интерфейса реализовано два метода:

+ `void forward(ServletRequest var1, ServletResponse var2)` — передает запрос из сервлета к другому 
ресурсу (сервлету, JSP или HTML файлу) на сервере.
+ `void include(ServletRequest var1, ServletResponse var2)` — включает контент ресурса (сервлет, JSP или HTML страница) 
в ответ.

Доступ к интерфейсу можно получить с помощью метода 
интерфейса `ServletContext` - `RequestDispatcher getRequestDispatcher(String path)`, 
где путь начинающийся с `/`, интерпретируется относительно текущего корневого пути контекста.

[к оглавлению](#Servlet)

## 15. Как можно создать блокировку (deadlock) в сервлете?

Дедлок можно получить реализовав зацикленный вызов метода, например, вызвав метод `doPost()` в методе `doGet()` 
и метод `doGet()` в методе `doPost()`.

[к оглавлению](#Servlet)

## 16. Как получить адрес сервлета на сервере?

Реальный путь к расположению сервлета на сервере можно получить из объекта `ServletContext`: 

`getServletContext().getRealPath(request.getServletPath())`.

[к оглавлению](#Servlet)

## 17. Как получить информацию о сервере из сервлета?

Информацию о сервере можно получить из объекта `ServletContext` с помощью метода `getServerInfo()`: 

`getServletContext().getServerInfo()`.

[к оглавлению](#Servlet)

## 18. Как получить ip адрес клиента на сервере?

Для получения в сервлете IP адреса клиента на сервере можно получить вызвав `request.getRemoteAddr()`.

[к оглавлению](#Servlet)

## 19. Что вы знаете о классах обертках (wrapper) для сервлетов?

Собственные обработчики `ServletRequest` и `ServletResponse` можно реализовать добавив новые или переопределив 
существующие методы у классов-обёрток `ServletRequestWrapper` (`HttpServletRequestWrapper`) и 
`ServletResponseWrapper` (`HttpServletRequestWrapper`).

Данные классы-обертки помогают разработчикам реализовывать собственные реализации типов `request` и `response` сервлета. 
Можно расширить эти классы и переопределить только необходимые методы для реализации собственных типов объектов ответов и запросов. 
Эти классы не используются в стандартном программировании сервлетов.

[к оглавлению](#Servlet)

## 20. Каков жизненный цикл сервлета и когда какие методы вызываются?

Контейнер сервлетов управляет четырьмя фазами жизненного цикла сервлета:

+ **Загрузка класса сервлета** — когда контейнер получает запрос для сервлета, то происходит загрузка класса сервлета в 
память и вызов его конструктора без параметров.
+ **Инициализация класса сервлета** — после того как класс загружен контейнер инициализирует объект `ServletConfig` для этого 
сервлета и внедряет его через `init()` метод. Это и есть место где сервлет класс преобразуется из обычного класса в сервлет.
+ **Обработка запросов** — после инициализации сервлет готов к обработке запросов. Для каждого запроса клиента сервлет 
контейнер порождает новый поток и вызывает метод `service()` путем передачи ссылки на объект ответы и запроса.
+ **Удаление из Service** - когда контейнер останавливается или останавливается приложение, то контейнер сервлетов 
уничтожает классы сервлетов путем вызова `destroy()` метода.

Таким образом, сервлет создаётся при первом обращении к нему и живёт на протяжении всего времени работы приложения 
(в отличии от объекты классов, которые уничтожаются сборщиком мусора после того как они уже не используются) и весь 
жизненный цикл сервлета можно описать как последовательность вызова методов:

+ `public void init(ServletConfig config)` – используется контейнером для инициализации сервлета. 
Вызывается один раз за время жизни сервлета.
+ `public void service(ServletRequest request, ServletResponse response)` – вызывается для каждого запроса. 
Метод не может быть вызван раньше выполнения `init()` метода.
+ `public void destroy()` – вызывается для уничтожения сервлета (один раз за время жизни сервлета).

https://docs.oracle.com/javaee/7/tutorial/servlets002.htm#BNAFI

[к оглавлению](#Servlet)

## 21. Какие методы необходимо определить при создании сервлетов?

Чтобы создать сервлет, необходимо описать его в дескрипторе развёртывания:

>Пример 1

```xml
<servlet-mapping> 
  <servlet-name>MyOwnDefaultServlet</servlet-name>
  <url-pattern>/myservlet/*</url-pattern>
</servlet-mapping>
 
<servlet>
  <servlet-name>HelloWorld2</servlet-name> 
  <servlet-class>examples.servlets.HelloWorld2</servlet-class>
   <init-param>
    <param-name>greeting</param-name> 
    <param-value>Welcome</param-value> 
  </init-param>
   <init-param>
    <param-name>person</param-name> 
    <param-value>WebLogic Developer</param-value> 
  </init-param>
</servlet>
```

>Пример 2

```xml
<servlet-mapping>
    <servlet-name>ExampleServlet</servlet-name>
    <url-pattern>/example</url-pattern>
</servlet-mapping>

<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <init-param>
        <param-name>config</param-name>
        <param-value>default</param-value>
    </init-param>       
</servlet>
```

Затем создать класс сервлета `examples.servlets.HelloWorld2` или для примера 2 `xyz.company.ExampleServlet`
путём наследования от `HttpServlet` и реализовать логику его работы 
в методе `service()` или методах `doGet()`/`doPost()` (или первый или вторые).

[к оглавлению](#Servlet)

## 22. В каком случае вы будете переопределять метод service()?

Метод `service()` переопределяется, когда необходимо, чтобы сервлет обрабатывал все запросы (и `GET`, и `POST`) в одном методе.

Когда контейнер сервлетов получает запрос клиента, то происходит вызов метода `service()`, 
который в зависимости от поступившего запроса вызывает или метод `doGet()` или метод `doPost()`.

[к оглавлению](#Servlet)

## 23. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?

Такая возможность есть, но считается бессмысленной. 
Инициализировать данные лучше не в конструкторе, а переопределив метод `init()`, 
в котором имеется возможность доступа к параметрам инициализации сервлета через использование объекта `ServletConfig`.

[к оглавлению](#Servlet)

## 24. В чем отличия GenericServlet и HttpServlet?

Абстрактный класс `GenericServlet` — независимая от используемого протокола реализация интерфейса `Servlet`, 
а абстрактный класс `HttpServlet` в свою очередь расширяет `GenericServlet` для протокола HTTP.

Следует отметить, что HttpServlet extends GenericServlet.

https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html

https://docs.oracle.com/javaee/7/api/javax/servlet/GenericServlet.html

[к оглавлению](#Servlet)

## 25. Как вызвать из сервлета другой сервлет этого же и другого приложения?

Для вызова сервлета из того же приложения необходимо использовать механизм внутренней коммуникации сервлетов 
(_inter-servlet communication mechanisms_) через вызовы методов `RequestDispatcher` - `forward()` и `include()` 
для доступа к дополнительным атрибутам в запросе для использования в другом сервлете:
 
+ `forward()` - передаёт выполнение запроса в другой сервлет;
+ `include()` - предоставляет возможность включить результат работы другого сервлета в возвращаемый ответ.

Если необходимо вызывать сервлет принадлежащий другому приложению, то использовать `RequestDispatcher` уже не получится, 
т.к. он определен только для текущего приложения. Для подобных целей необходимо использовать 
метод `ServletResponse` - `sendRedirect()` которому предоставляется полный URL из другого сервлета. 
Для передачи данных между сервлетами можно использовать `cookies`. 
(т.е. можно использовать `cookies` как часть ответа сервлета, а потом использовать их в нашем сервлете)

[к оглавлению](#Servlet)

## 26. Что вы знаете и в чем отличия методов forward() и sendRedirect()?

RequestDispatcher forward() используется для проброски того же самого запроса к другому ресурсу, 
в то время как ServletResponse sendRedirect() это двухшаговый метод. 
Во втором методе веб приложение возвращает ответ клиенту с status code 302 (redirect) с ссылкой для отправки запроса. 
Запрос посылает полностью новый запрос.
forward() обрабатывается внутри контейнера, а sendRedirect() обрабатывается браузером.
Необходимо использовать forward() для организации доступа внутри одного и того же приложения, 
т.к. он быстрее sendRedirect(), которому требуется дополнительная сетевая работа.
В методе forward() браузер не знает о фактически обрабатываемом ресурсе и URL в строке остается прежним. 
В sendRedirect() методе URL адрес изменяется на пробрасываемый ресурс.
В методе forward() нельзя использовать для внедрения сервлета в другой контекст. Для этого можно использовать только sendRedirect().

[к оглавлению](#Servlet)

## 27. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?

Методы класса HTTPServlet init() и destroy() вызываются один раз за жизненный цикл сервлета — поэтому по поводу них беспокоиться не стоит. 
Методы doGet(), doPost() вызываются на каждый запрос клиента и т.к. сервлеты используют многопоточность, 
то здесь нужно задумываться о потокобезопасной работе.
В случае наличия локальных переменных в этих методах нет необходимости думать о многопоточной безопасности, 
т.к. они будут созданы отдельно для каждой нити. 
Но если используются глобальные ресурсы, то необходимо использовать синхронизацию как и в любом многопоточном приложении Java.

[к оглавлению](#Servlet)

## 28. В чем отличие между веб сервером и сервером приложений?

Веб сервер необходим для обработки HTTP request от браузера клиента и ответа клиенту с помощью HTTP response. 
Веб сервер понимает язык HTTP и запускается по HTTP протоколу. 
Примером веб сервера может служить реализация от Apache — Tomcat.
Сервер приложений предоставляет дополнительные возможности, 
такие как поддержка JavaBeans, JMS Messaging, Transaction Management и др. 
Можно сказать, что сервер приложений — это веб сервер с дополнительными возможностями, 
которые помогают разрабатывать корпоративные приложения.

[к оглавлению](#Servlet)

## 29. Какой метод HTTP не является неизменяемым?

HTTP метод называется неизменяемым, если он всегда возвращает одинаковый результат. 
HTTP методы GET, PUT, DELETE, HEAD, OPTIONS являются неизменяемыми. 
Необходимо реализовывать приложение так, чтобы эти методы возвращали одинаковый результат. 
К изменяемым методам относится HTTP метод POST. Post метод используется для реализации чего-либо, что изменяется при каждом запросе.
К примеру, для доступа к HTML странице или изображению необходимо использовать метод GET, т.к. он возвращает одинаковый результат. 
Но если нам необходимо сохранить информацию о заказе в базе данных, то нужно использовать POST метод. 
Неизменяемые методы так же известны как безопасные методы и нет необходимости заботиться о повторяющихся запросах от клиента для этих методов.

[к оглавлению](#Servlet)

## 30. Почему HttpServlet класс объявлен как абстрактный?

Класс HTTPServlet предоставляет реализацию HTTP протокола сервлета 
(а следовательно помогает избежать постоянного кодинга повторяющейся информации), 
но он не имеет реализованных методов doGet() и doPost() (у них по умолчанию возвращение HTTP 405 Method Not Implemented error), 
а следовательно объявлен абстрактным. Реализация этих методов перекладывается на разработчика.

[к оглавлению](#Servlet)

## 31. В чем разница между методами GET и POST?

+ GET метод является неизменяемым, тогда как POST — изменяемый.
+ С помощью метода GET можно посылать ограниченное кол-во данных, которые будут пересланы в заголовке URL. 
В случае POST метода мы можем пересылать большие объемы данных, т.к. они будут находится в теле метода.
+ Данные GET метода передаются в открытом виде, что может использоваться в зловредных целях. 
POST данные передаются в теле запроса и скрыты от пользователя.
+ GET метод является HTTP методом по умолчанию, а POST метод необходимо указывать явно, чтобы отправить запрос.
+ GET метод используется гиперссылками на странице.

[к оглавлению](#Servlet)

## 32. Что такое MIME тип?

MIME (произн. «майм», англ. Multipurpose Internet Mail Extensions — многоцелевые расширения интернет-почты) — стандарт, 
описывающий передачу различных типов данных по электронной почте, а также, в общем случае, 
спецификация для кодирования информации и форматирования сообщений таким образом, чтобы их можно было пересылать по Интернету. 
Content-Type response header это и есть MIME тип. 
Сервер посылает MIME тип клиенту для того, чтобы он понял какой тип данных пересылается. 
Это помогает верно отобразить полученные данные на клиенте. 
Наиболее часто используемые MIME типы: text/html, text/xml, application/xml и многие др.
В ServletContext существует метод getMimeType() для получения корректного MIME типа файла 
и дальнейшего использования этой информации для указания типа контента в ответе.

[к оглавлению](#Servlet)

## 33. Назовите преимущества Servlet над CGI?

Технология сервлетов была создана для преодоления недостатков Common Gateway Interface (общий интерфейс шлюза). 
Можно выделить следующие преимущества сервлетов над CGI:

+ Сервлеты предоставляют лучшую производительность в условиях обработки запросов, 
лучшее использование памяти за счет использования преимущество многопоточности 
(на каждый запрос создается новая нить, что быстрее выделения памяти под новый объект для каждого запроса, как это происходит в CGI).
+ Сервлеты, платформа и система являются независимыми. 
Таким образом веб приложение написанное с использованием сервлетов может быть запущена в любом контейнере сервлетов, 
реализующим стандарт и в любой операционной системе.
+ Использование сервлетов повышает надежность программы, 
т.к. контейнер сервлетов самостоятельно заботится о жизненном цикле сервлетов (а значит и за утечками памяти), 
безопасности и сборщике мусора.
+ Сервлеты относительно легки в изучении и поддержке, таким образом разработчику необходимо заботиться только о бизнес логике приложения, 
а не внутренней реализации веб технологий.

[к оглавлению](#Servlet)

## 34. Каковы наиболее распространенные задачи выполняются в Servlet контейнере?

+ Поддержка обмена данными. Контейнер сервлетов предоставляет легкий способ обмена данными между веб клиентом (браузером) и сервлетом. 
Благодаря контейнеру нет необходимости создавать слушателя сокета на сервере для отслеживания запросов от клиента, 
а так же разбирать запрос и генерировать ответ. 
Все эти важные и комплексные задачи решаются с помощью контейнера и разработчик может сосредоточиться на бизнес логике приложения.
+ Управление жизненным циклом сервлетов и ресурсов. Начиная от загрузки сервлета в память, инициализации, внедрения методов и заканчивая уничтожением сервлета. 
Контейнер так же предоставляет дополнительные утилиты, например JNDI, для управления пулом ресурсов.
+ Поддержка многопоточности. Контейнер самостоятельно создает новую нить для каждого запроса и предоставляет ей запрос и ответ для обработки. 
Таким образом сервлет не инициализируется заново для каждого запроса и тем самым сохраняет память и уменьшает время до обработки запроса.
+ Поддержка JSP. JSP классы не похожи на стандартные классы джавы, но контейнер сервлетов преобразует каждую JSP в сервлет и далее управляется контейнером как обычным сервлетом.
+ Различные задачи. Контейнер сервлетов управляет пулом ресурсов, памятью приложения, сборщиком мусора. Предоставляются возможности настройки безопасности и многое другое.

[к оглавлению](#Servlet)

## 35. В чем разница между PrintWriter и ServletOutputStream?

PrintWriter — это класс для работы с символьным потоком, а ServletOutputStream — класс для работы байтовым потоком. 
PrintWriter используется для записи информации на основе символов, вроде массива символов или строки в ответ, 
в то время как ServletOutputStream используется для записи в ответ массива байтов. 
Для получения экземпляра ServletOutputStream используется метод ServletResponse getOutputStream(), 
а для PrintWriter — метод ServletResponse getWriter().

[к оглавлению](#Servlet)

## 36. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?

Мы не можем создать два объекта этих классов в одном сервлете. 
При попытке внедрить оба метода getWriter() и getOutputStream() в ответе, 
мы получим исключение java.lang.IllegalStateException с сообщением, что уже другой метод был вызван для этого ответа.

[к оглавлению](#Servlet)

## 37. Расскажите о интерфейсе SingleThreadModel?

Интерфейс был создан, чтобы гарантировать потокобезопасность и невозможности создания двух нитей в сервис методе сервлета. 
Однако интерфейс SingleThreadModel не решает всех проблем потокобезопасности. 
Например, атрибуты сессии или статические переменные могут быть доступны различным запросам в различных потоках в одно и тоже время 
(даже при использовании этого интерфейса). В общем это убило весь профит от многопоточности и интерфейс объявлен deprecated начиная с Servlet 2.4.

[к оглавлению](#Servlet)

## 38. Какие существуют атрибуты у сервлетов и какая сфера их применения?

Атрибуты сервлетов ипользуются для внутренней коммуникации сервлетов. 
Мы можем использовать атрибуты set, get, remove в веб приложении. 
Существует три области видимости атрибутов — request scope, session scope, application scope.
Интерфейсы ServletRequest, HttpSession и ServletContext предоставляют методы для get(), set(), remove() атрибутов из request scope, 
session scope, application scope соответственно.

[к оглавлению](#Servlet)

## 39. Почему необходимо переопределить только init() метод без аргументов?

Если нам необходимо инициализировать какие-то ресурсы до того как сервлет начнет обрабатывать запросы, то необходимо переопределить метод init(). 
Если переопределить метод init(ServletConfig config), то первым должен быть вызван метод super(config), 
который обеспечит вызов метода init(ServletConfig config) суперкласса. 
Именно поэтому GenericServlet предоставляет другой метод init() без параметров, 
который будет вызываться в конце метода init(ServletConfig config). 
Разработчик должен использовать переопределенный метод init() без параметров для инициализации переменных для избежания каких-либо проблем, 
например не указав вызов super() в переопределенном методе init(ServletConfig config).

[к оглавлению](#Servlet)

## 40. Что означает URL encoding Зачем нужны методы javanetURLEncoderencode() и decode()?

URL Encoding — процесс преобразования данных в форму CGI (Common Gateway Interface), 
который позволит путешествовать по сети без проблем. 
URL Encoding разделяет пробелы и заменяет специальные символы с помощью escape-симолов. 
Например, для кодирования строки используется метод  java.net.URLEncoder.encode(String str, String unicode). 
Обратная операция декодирования возможна благодаря методу java.net.URLDecoder.decode(String str, String unicode). 
Пример работы метода: строка «Java for study .ru» будет преобразована в Java%20for%20study%20.ru.

[к оглавлению](#Servlet)

## 41. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?

HttpServletResponse предоставляет методы преобразования URL в HTML гиперссылки с преобразованием спец символов и пробелов, 
а так же добавления session id к URL. Такое поведение аналогично URLEncoder encode(), но с добавлением дополнительного параметра jsessionid в конец URL.
Метод HttpServletResponse encodeRedirectUrl() применяется для преобразования redirect URL в ответе. 
Таким образом при предоставлении поддержки URL rewriting для HTML гиперссылок необходимо использовать encodeURL(), 
а для редирект URL’ов использовать encodeRedirectUrl().

[к оглавлению](#Servlet)

## 42. Какие различные методы управления сессией в сервлетах вы знаете?

Сессия является обычным состоянием взаимодействия сервера и клиента и может содержать в себе множество запросов и ответов клиент-сервер. 
Т.к. HTTP и веб сервер не запоминают состояния (stateless), 
то единственным способом поддерживать сессию является пересылка уникальной информации (session id) в каждом запросе и ответе между клиентом и сервером.

Существуют несколько распространенных способов управления сессией в сервлетах:

+ Аутентификация пользователя
+ HTML hidden field (скрытое поле)
+ Cookies
+ URL Rewriting
+ Session Management API

http://www.journaldev.com/1907/java-servlet-session-management-tutorial-with-examples-of-cookies-httpsession-and-url-rewriting

[к оглавлению](#Servlet)

## 43. Что означает URL Rewriting?

Для управления сессией в сервлетах мы можем использовать HTTPSession, но он работает с Cookies, а их иногда отключают. 
Для этого случая в сервлетах предусмотрена возможность URL Rewriting. 
С точки зрения программирования необходимо всего одно действие — кодирование URL. 
Другим достоинством является то, что этот метод является как бы запасным и включается только при выключенных куках.

Применяя метод HttpServletResponse encodeURL() мы можем закодировать URL. Если необходим редирект к другому ресурсу, 
то для предоставления информации о сессии применяется метод encodeRedirectURL().

[к оглавлению](#Servlet)

## 44. Как применяются Cookies в сервлетах?

Cookies (куки) используются в клиент-серверном взаимодействии и они не являются чем-то конкретным к Java. 
Servlet API предоставляет поддержку cookies через класс javax.servlet.http.Cookie implements Serializable, Cloneable. 
Для получения массива cookies из запроса необходимо воспользоваться методом HttpServletRequest getCookies(). 
Для добавления cookies в запрос методов не предусмотрено.

Аналогично HttpServletResponse addCookie(Cookie c) — может добавить cookie в response header, но не существует геттера для этого типа передачи данных.

http://www.journaldev.com/1956/servlet-cookie-example-tutorial

[к оглавлению](#Servlet)

## 45. Как уведомить объект в сессии, что сессия недействительна или закончилась?

Чтобы быть уверенным об оповещение объекта о прекращении сессии, 
объект должен реализовывать интерфейс javax.servlet.http.HttpSessionBindingListener. 
Два метода этого интерфейса: valueBound() и valueUnbound() применяются для реализации логики при добавлении объекта 
в качестве атрибута к сессии и при уничтожения сессии.

http://www.journaldev.com/1945/servlet-listener-example-servletcontextlistener-httpsessionlistener-and-servletrequestlistener

[к оглавлению](#Servlet)

## 46. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?

Сервлет фильтры используются для перехвата всех запросов между контейнером сервлетов и сервлетом. 
Поэтому логично использовать фильтр для проверки необходимой информации (например валидности сессии) в запросе.

[к оглавлению](#Servlet)

## 47. Как мы можем обеспечить transport layer security для нашего веб приложения?

Для этого необходимо настроить SSL для вашего сервлет контейнера. 
Как это сделать описано в мануалах для конкретной реализации контейнера.

[к оглавлению](#Servlet)

## 48. Как организовать подключение к базе данных и обеспечить логирование log4j в сервлете?

При работе с большим количеством подключений к базе данных рекомендуется инициализировать их в servlet context listener 
и установить в качестве атрибута контекста для возможности использования другими сервлетами. 
Логирование Log4j подключается с помощью конфигурации XML (или файла property) и далее эта информация 
используется при конфигурировании context listener’а.

http://www.journaldev.com/1997/servlet-example-in-java-with-database-connection-and-log4j-integration

[к оглавлению](#Servlet)

## 49. Какие важные особенности существуют в Servlet 3?

+ Servlet Annotations. До Servlet 3 весь маппинг был в web.xml, что приводило к ошибкам и банально неудобно 
при большом количестве сервлетов. Примеры аннотаций:  @WebServlet, @WebInitParam, @WebFilter, @WebListener.
+ Web Fragments. С появлением веб фрагментов мы можем содержать множество модулей в одностраничном веб приложении. 
Все модули прописываются в fragment.xml в META-INF директории. Это позволяет разделять веб приложение на отдельные 
модули, включенные как JAR файлы в отдельной lib директории.
+ Динамическое добавление веб компонентов. Используя ServletContext объект, мы можем программно добавлять 
фильтры и слушатели. Это помогает построить динамическую систему, в которой необходимый объект будет вызван 
только по необходимости. Для этого применяются методы addServlet(), addFilter(), addListener().
+ Асинхронное выполнение. Поддержка асинхронной обработки позволяет передать выполнение запроса в другой поток 
без удержания всего сервера занятым.

http://www.journaldev.com/2008/async-servlet-feature-of-servlet-3

[к оглавлению](#Servlet)

## 50. Каковы различные способы аутентификации сервлета?

Контейнер сервлетов предоставляет различные способы аутентификации:

+ HTTP Basic Authentication
+ HTTP Digest Authentication
+ HTTPS Authentication
+ Form Based Login

[к оглавлению](#Servlet)

## 51. Написать сервлет, реализующий загрузку файла на сервер?

http://www.journaldev.com/1964/servlet-upload-file-and-download-file-example

[к оглавлению](#Servlet)


## Источники:

Java Servlet Specification 4.0 https://javaee.github.io/servlet-spec/downloads/servlet-4.0/servlet-4_0_FINAL.pdf

Java Servlet Technology https://docs.oracle.com/javaee/7/tutorial/servlets.htm#BNAFD

https://docs.oracle.com/javaee/7/JEETT.pdf

https://docs.oracle.com/javaee/7/api/javax/servlet/Servlet.html
