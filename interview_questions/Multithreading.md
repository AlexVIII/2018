## Multithreading

[1. Чем отличается процесс от потока?](#1-Чем-отличается-процесс-от-потока)

[2. Каким образом можно создать поток?](#2-Каким-образом-можно-создать-поток)

[3. Как работают методы sleep, yield, wait, notify и notifyAll?](#3-Как-работают-методы-sleep-yield-wait-notify-и-notifyAll)

[4. Объясните следующие термины: монитор, мьютекс, критическая секция?](#4-Объясните-следующие-термины-монитор-мьютекс-критическая-секция)

[5. Как работает join()?](#5-Как-работает-join)

[6. Что такое DeadLock? Приведите примеры.](#6-Что-такое-DeadLock-Приведите-примеры)

[7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap?](#7-Назовите-различия-между-CollectionssynchronizedMapnew-HashMap-и-ConcurrentHashMap)

[8. Различия в интерфейсах Runnable и Callable?](#8-Различия-в-интерфейсах-Runnable-и-Callable)

[9. Различя между isInterrupted(), interrupted()?](#9-Различя-между-isInterrupted-interrupted)

[10. Что происходит при вызове Thread.interrupt()?](#10-Что-происходит-при-вызове-Threadinterrupt)

[11. Перечислите ВСЕ причины по которым может выскочить InterruptedException?](#11-Перечислите-ВСЕ-причины-по-которым-может-выскочить-InterruptedException)

[12. Назовите отличия synchronize{} и ReentrantLock.](#12-Назовите-отличия-synchronize-и-ReentrantLock)

[13. Приведите наиболее существенное отличие между CountDownLatch и Barrier?](#13-Приведите-наиболее-существенное-отличие-между-CountDownLatch-и-Barrier)

[14. Отличие Thread.start() и Thread.run()?](#14-Отличие-Threadstart-и-Threadrun)

[15. Объясните ключевое слово volatile.](#15-Объясните-ключевое-слово-volatile)

[16. Расскажите про приоритеты потока?](#16-Расскажите-про-приоритеты-потока)

[17. Что такое потоки-демоны?](#17-Что-такое-потоки-демоны)

[18. Назовите все возможные состояния потока?](#18-Назовите-все-возможные-состояния-потока)

[19. Что такое race condition?](#19-Что-такое-race-condition)

[20. Что такое Thread Local переменная?](#20-Что-такое-Thread-Local-переменная)

[21. Что такое FutureTask?](#21-Что-такое-FutureTask)

[22. Что такое Thread Pool?](#22-Что-такое-Thread-Pool)

[23. Что такое Semaphore?](#23-Что-такое-Semaphore)

[24. Чем отличается submit от execute у ExecutorServices?](#24-Чем-отличается-submit-от-execute-у-ExecutorServices)

[25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?](#25-Чем-отличается-shutdown-от-shutdownNow-у-ThreadPoolExecutor)

[26. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков?](#26-Как-создать-ThreadPool-у-ExecutorService-только-на-1-на-5-на-неограниченное-количество-потоков)

[27. Что такое ReadWriteLock?](#27-Что-такое-ReadWriteLock)

[28. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel()?](#28-В-чём-отличие-Thread-от-FutureTask-В-чём-отличие-Threadinterrupt-и-FutureTaskcancel)

[29. Расскажите про шаблон проектирования Producer Consumer?](#29-Расскажите-про-шаблон-проектирования-Producer-Consumer)

[30. ](#30-)

## 1. Чем отличается процесс от потока?

Как правило, каждое запущенное приложение состоит из набора взаимодействующих процессов.

**Процесс** - это программа, которая выполняет некоторый код, и у него есть своя область памяти (минимум 1 поток).

**Поток** - это паралельные нити выполнения внутри одного процесса, которые разделяют его общую память.

Еще разок:

**Процесс** - это совокупность кода и данных, разделяющих общее виртуальное адресное пространство.
Процессы изолированы друг от друга, поэтому прямой доступ к памяти чужого процесса невозможен 
(взаимодействие между процессами осуществляется с помощью специальных средств). 
Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет 
прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. 
Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.

**Поток** («нить» или «трэд») – это одна единица исполнения кода в процессе. Каждый поток последовательно выполняет 
инструкции процесса, которому он принадлежит, параллельно с другими потоками этого процесса.

Процесс может иметь более одного потока для выполнения независимой задачи, например, поток для чтения данных с диска, 
поток для обработки этих данных и другой поток для отправки этих данных по сети. 

Многопоточность - это способ повышения пропускной способности и лучшего использования мощности процессора, т.к. 
потоки исполняются на ядрах процессора. В некоторых OS разница между процессами и потоками сведена к минимуму. 
В контексте Java разница между этими понятиями радикальная (см. классы Thread и Process). 

https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html

https://techdifferences.com/difference-between-process-and-thread-in-java.html

[к оглавлению](#Multithreading)

## 2. Каким образом можно создать поток?

+ Создать потомка класса `Thread` и переопределить его метод `run()`;
    ```java
    public class HelloThread extends Thread {
        
        @Override
        public void run() {
            System.out.println("Hello from a thread!");
        }
    
        public static void main(String args[]) {
            (new HelloThread()).start();
        }
    }
    ```
+ Создать объект класса `Thread`, передав ему в конструкторе экземпляр класса, реализующего интерфейс `Runnable`. 
Этот интерфейс содержит метод `run()`, который будет выполняться в новом потоке. Поток закончит выполнение, 
когда завершится его метод `run()`.
    ```java
    public class HelloRunnable implements Runnable {
        
        @Override
        public void run() {
            System.out.println("Hello from a thread!");
        }
    
        public static void main(String args[]) {
            (new Thread(new HelloRunnable())).start();
        }  
    }
    ```

+ Вызвать метод `submit()` у экземпляра класса реализующего интерфейс `ExecutorService`, передав ему в качестве 
параметра экземпляр класса, реализующего интерфейс `Runnable` или `Callable` 
(содержит метод `call()`, в котором описывается логика выполнения).

    ```java
    public class CallableExample {
     
      public static class WordLengthCallable implements Callable {
          private String word;
          public WordLengthCallable(String word) {
              this.word = word;
          }
          public Integer call() {
              return Integer.valueOf(word.length());
          }
      }
     
      public static void main(String args[]) throws Exception {
          ExecutorService pool = Executors.newFixedThreadPool(3);
          Set<Future<Integer>> set = new HashSet<Future<Integer>>();
          for (String word: args) {
              Callable<Integer> callable = new WordLengthCallable(word);
              Future<Integer> future = pool.submit(callable);
              set.add(future);
          }
          int sum = 0;
          for (Future<Integer> future : set) {
              sum += future.get();
          }
          System.out.printf("The sum of lengths is %s%n", sum);
          System.exit(sum);
      }
    }
    ```

https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html

[к оглавлению](#Multithreading)

## 3. Как работают методы sleep, yield, wait, notify и notifyAll?

+ `sleep` - усыпляет поток некоторое время, не освобождая lock объект (локи\мониторы\ресурсы).
+ `wait` - усыпляет поток, освобождает lock объект.
+ `notify` - будит последний стоящий в очереди поток.
+ `notifyAll` - будит все стоящие в очереди объекты.
+ `yield` - принудительно передает квант времени следующему потоку, т.е. уступает очередь потокам.

Методы `wait`, `notify` и `notifyAll` класса `Object` позволяют работать с синхронизацией и lock-ами (мониторами) 
на более низком уровне. 
(см. Effective Java и пример Петра https://www.youtube.com/watch?v=6pwM3p2pbic&list=PLW8mAQ8rFUhKFkuXDTb3PT1GKz0T-lCv6&index=13)

[к оглавлению](#Multithreading)

## 4. Объясните следующие термины: монитор, мьютекс, критическая секция?

В многопоточном приложении двум или нескольким потокам может потребоваться одновременный доступ к общему ресурсу, 
что приводит к неожиданному поведению. Примерами таких общих ресурсов являются структуры данных, 
устройства ввода-вывода, файлы и сетевые подключения.
 
**Критическая секция** - часть исполняемого кода программы, которая обращается к общему ресурсу 
(данным или устройству), который не должен быть одновременно использован более чем одним потоком выполнения. 
При нахождении в критической секции двух или более потоков возникает состояние «гонки». 
Чтобы избежать состояния гонки, нужно синхронизировать доступ к критическому разделу.

**Мьютекс** (MUTual EXclusion или взаимное исключение) - это самый простой тип синхронизатора потоков/нитей, который 
гарантирует, что только один поток может одновременно выполнять критический раздел компьютерной программы.
Мьютекс может принимать два состояния – занят и свободен. 

Удобно представлять мьютекс как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. 
Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.

Чтобы получить доступ к критическому разделу, поток получает мьютекс, затем обращается к критическому разделу и, 
наконец, освобождает мьютекс. Тем временем все остальные потоки блокируются до освобождения мьютекса. 
Как только поток выходит из критической секции, другой поток может войти в критическую секцию.

*Задача мьютекса* — защита объекта от доступа к нему других потоков, отличных от того, который завладел мьютексом. 
В каждый конкретный момент только один поток может владеть объектом, защищённым мьютексом. 
Если другому потоку будет нужен доступ к объекту, то этот поток блокируется до тех пор, пока мьютекс не будет освобождён.

*Цель использования мьютексов* — защита данных от повреждения в результате асинхронных изменений (состояние гонки), 
однако могут порождаться другие проблемы — например взаимная блокировка ([DeadLock](#Что-такое-DeadLock)).

Работать с мютексом в Java можно посредством монитора.
**Монитор** – это высокоуровневая надстройка над мютексом (по факту кусок кода), которая обеспечивает правильную работу с ним. 

В Java монитор реализован с помощью ключевого слова `synchronized`. 
Используется он так: любой нестатический `synchronized`-метод при своем вызове прежде всего пытается захватить монитор 
того объекта, у которого он вызван (на который он может сослаться как на `this`). Если это удалось – метод исполняется. 
Если нет – поток останавливается и ждет, пока монитор будет свободен.

Итого:

**Монитор и мьютекс – это средство обеспечения контроля за доступом к ресурсу.**

**Мьютекс синхронизирует доступ потоков к критической секции, а монитор обеспечивает правильную работу с мьютексом
посредством `synchronized`.**

*Пример из жизни: очередь в туалет, где очередь - это потоки, дверной замок - мьютекс, 
блок электронного управления замком с маячком - монитор, а туалет - критическая секция.*

Когда человек заходит в туалет, он закрывает изнутри дверь на замок.
Туалет выполняет роль объекта, доступ к которому получают несколько потоков. 
Замок на двери туалета — роль мьютекса, а очередь из людей снаружи — роль потоков.
Замок на двери — мьютекс туалета: он гарантирует, что внутри одновременно может находиться только один человек. 
Иными словами, только один поток в определенное время может работать с общими ресурсами. 
Попытки других потоков (людей) получить доступ к занятым ресурсам будут неудачными.

https://www.baeldung.com/java-mutex

https://stackoverflow.com/questions/3362303/whats-a-monitor-in-java

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html

https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html

[к оглавлению](#Multithreading)

## 5. Как работает join()?

`join()` — текущий поток ждет другой поток.

Когда поток A вызывает `join()` для потока B, текущий работающий поток A будет ждать, пока поток B, 
к которому он присоединяется, не будет завершён:
```java
    void join()        
    void join(long millis) 
    void join(long millis, int nanos) 
```

Например, у нас есть основной/родительский тред и порожденные в нем дочерние треды. 
Если мы хотим, чтобы все дочерние треды были закончены до завершения родительского треда, нужно заджойнить их 
в родительский тред. Т.е. родительский тред будет ждать, пока все дочерние треды закончатся.

`join()` может использоваться при параллельном вычислении для больших формул, 
параллельных сортировках - разбиваем дерево и сортируем его отдельно по веткам.

[к оглавлению](#Multithreading)

## 6. Что такое DeadLock Приведите примеры?

**Deadlock или взаимная блокировка** описывает ситуацию, когда два или более потоков заблокированы навсегда, 
ожидая друг друга.

Например, строгое правило вежливости гласит: когда вы кланяетесь другу, вы должны оставаться в поклоне, 
пока ваш друг тоже не поклонится вам. К сожалению, два человека могут поклониться друг другу одновременно.

Синонимом Deadlock называют Livelock, когда все потоки занимаются бесполезной работой и состояние системы 
не меняется с течением времени.

Виды взаимных блокировок:
+ Взаимоблокировки, вызванные порядком наложения блокировок.
+ Взаимоблокировки, вызванные динамическим порядком блокировок (или взаимная блокировка порядка синхронизации)
+ Взаимоблокировки между взаимодействующими объектами.
+ Взаимоблокировки ресурсов.

Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь так: 
1. Если есть возможность, захватывайте не более одной блокировки за один раз.
2. Если необходимо захватить несколько блокировок, попробуйте свести к минимуму число потенциальных взаимодействий 
между блокировками. Т.е. получайте мониторы разделяемых ресурсов в определённом порядке и освобождайте их в обратном порядке.

Диагностика взаимоблокировок:
1. Ограничение взаимоблокировок по времени.
2. Анализ взаимоблокировок с использованием дампов потоков.

Далее подробно.

+ **Взаимоблокировки, вызванные порядком наложения блокировок.**

    Взаимоблокировка в классе LeftRightDeadlock произошла потому, что два потока пытались захватить блокировки в различном 
порядке (different order). Если бы они запрашивали блокировки в одном и том же порядке, не было бы никакой циклической 
зависимости между блокировками и, следовательно, никакой взаимоблокировки бы не произошло.
```java
public class LeftRightDeadlock {
    private final Object left = new Object(); private final Object right = new Object();
        public void leftRight() {
            synchronized (left) {
            synchronized (right) {
                doSomething();
            }
        }
    }
    public void rightLeft() {
        synchronized (right) {
            synchronized (left) {
                doSomethingElse();
            }
        }
    }
}
```

Решение. Программа будет свободна от взаимоблокировок вызванных порядком наложения блокировок, 
если все потоки будут получать необходимые им блокировки в глобально зафиксированном порядке.

+ **Взаимоблокировки, вызванные динамическим порядком блокировок** (или взаимная блокировка порядка синхронизации)
```java
    public void transferMoney(Account fromAccount, Account toAccount, Amount amount) throws InsufficientFundsException {
        synchronized (fromAccount) {
            synchronized (toAccount) {
                if (fromAccount.getBalance().compareTo(amount) < 0)
                    throw new InsufficientFundsException();
                else {
                    fromAccount.debit(amount);
                    toAccount.credit(amount);
                }
            }
        }
    }
```
Данная блокировка вызвана тем, что синхронизация счетов может происходить в разном порядке. 
Например, два потока одновременно вызывают метод transferMoney, один из которых 
производит перемещение из X в Y, а другой-наоборот:
```java
A: transferMoney(myAccount, yourAccount, 10);
B: transferMoney(yourAccount, myAccount, 20);
```

Решение. Соответственно, если ввести некоторый порядок на счетах (это некоторое правило, позволяющее сказать, 
что счет A меньше чем счет B), то проблема будет устранена.

Нужно индуцировать (induce - вызвать) упорядочение блокировок и захватывать их во всем приложении последовательно, в 
соответствии с индуцированным порядком. Одним из способов индуцирования упорядочивания объектов, является использование 
метода `System.identityHashCode`, который возвращает то же значение, которое будет возвращено методом `Object.hashCode`.

+ **Взаимоблокировки между взаимодействующими объектами**

```java
class Plane {
    private Point location, destination;
    private final Dispatcher dispatcher;
    
    public Plane(Dispatcher dispatcher) {
        this.dispatcher = dispatcher;
    }
    public synchronized Point getLocation() {
        return location;
    }
    public synchronized void setLocation(Point location) {
        this.location = location;
        if (location.equals(destination)) {
            dispatcher.requestLanding(this);
        }
    }
}
    
class Dispatcher {
    private final Set<Plane> planes;
    private final Set<Plane> planesPendingLanding;
    
    public Dispatcher() {
        planes = new HashSet<Plane>();
        planesPendingLanding = new HashSet<Plane>();
    }
    public synchronized void requestLanding(Plane plane) {
        planesPendingLanding.add(plane);
    }
    public synchronized Image getMap() {
        Image image = new Image();
        for (Plane plane : planes) {
            image.drawMarker(plane.getLocation());
        }
        return image;
    }
}
```

В результате, если самолет прибывает на место, в тот же момент, как кто-то решает получить карту может возникнуть 
взаимная блокировка. То есть, будут вызваны методы, `getMap` и `setLocation`, которые займут мониторы экземпляров 
`Dispatcher` и `Plane` соответственно. Затем метод `getMap` вызовет `plane.getLocation` (в частности для экземпляра `Plane`, 
который в данный момент занят), который будет ждать освобождения монитора для каждого из экземпляров `Plane`. 
В то же время в методе `setLocation` будет вызван `dispatcher.requestLanding`, 
при этом монитор экземпляра `Dispatcher` остается занят рисованием карты. Результат – взаимная блокировка.

Решение. Используйте открытые вызовы. То есть, вызывать методы других объектов вне синхронизированного блока. 
Если с применением принципа открытых вызовов переписать методы `setLocation` и `getMap`,
 возможность взаимной блокировки будет устранена. Выглядеть это будет, например, так:
```java
public void setLocation(Point location) {
	boolean reachedDestination;
	synchronized(this) {
		this.location = location;
		reachedDestination = location.equals(destination);
	}
	if (reachedDestination) {
		dispatcher.requestLanding(this);
	}
}
………………………………………………………………………………
public Image getMap() {
	Set<Plane> copy;
	synchronized(this) {
		copy = new HashSet<Plane>(planes);
	}
	Image image = new Image();
	for (Plane plane : copy) {
		image.drawMarker(plane.getLocation());
	}
	return image;
}
```

Старайтесь в своей программе использовать открытые вызовы. 
Программы, которые полагаются на открытые вызовы, гораздо легче анализировать на отсутствие взаимоблокировок, 
чем те, которые допускают вызов чужих методов в процессе удержания блокировки.

+ **Взаимоблокировки ресурсов**

Точно так же, как потоки могут попасть в ситуацию взаимоблокировки, когда каждый из них ожидает блокировку, удерживаемую 
другим потоком, и не освобождает свою, они также могут попасть в ситуацию взаимоблокировки при ожидании ресурсов.

Предположим, у вас есть два объединяющих ресурса, например пулы соединений для двух разных баз данных. Пулы ресурсов, 
как правило, реализуются с использованием семафоров для облегчения блокирования, когда пул пуст. 
Если задача требует подключения к обеим базам данных и оба ресурса не всегда запрашиваются в одном и том же порядке, 
поток A может удерживать подключение к базе D1, при ожидании подключения к базе D2, а поток B может удерживать 
подключение к базе D2, при ожидании подключения к базе данных D1. (Чем больше размер пулов, тем реже это происходит; 
если каждый пул имеет N соединений, для возникновения взаимоблокировки требуется N наборов циклически ожидающих потоков 
и множество неудачных моментов времени.)

**Предотвращение взаимоблокировок:**
1. Если есть возможность, захватывайте не более одной блокировки за один раз. Такая программа никогда не столкнется с 
взаимоблокировкой, вызванной порядком захвата блокировок.
2. Если вам необходимо захватить несколько блокировок, упорядочение блокировок должно быть частью дизайна программы: 
попробуйте свести к минимуму число потенциальных взаимодействий между блокировками.

**Диагностика взаимоблокировок:**
1. Блокировки, ограниченные по времени.

    Использование ограниченного по времени захвата блокировки, для захвата нескольких блокировок, может быть эффективным 
    средством против возникновения взаимоблокировки, даже если блокировка по времени используется во всей программе не 
    согласованно. Если время захвата блокировки истекло, вы можете освободить блокировки, отступить и подождать некоторое 
    время, а затем повторить попытку, возможно, очистив условие взаимоблокировки и позволив программе восстановиться. 
    (Этот подход работает только тогда, когда две блокировки захватываются вместе; если несколько блокировок захватываются 
    во вложенных вызовах методов, вы не можете просто освободить внешнюю блокировку, даже если вы знаете о том, что 
    удерживаете ее вы.)

2. Анализ взаимоблокировок с использованием дампов потоков.

    JVM может помочь идентифицировать их, когда они происходят, с помощью использования дампа потоков. Дамп потока 
    содержит трассировку стека для каждого запущенного потока, аналогичную трассировке стека, сопровождающей исключение. 
    Дампы потоков также включают в себя информацию о блокировании, например о том, какие блокировки удерживаются каждым 
    потоком, в каких кадрах стека они были захвачены, и какую блокировку ожидает захватить заблокированный поток. Перед 
    созданием дампа потока, JVM просматривает граф ожидания (is-waiting-for graph) в поисках циклов, для определения 
    наличия взаимоблокировок. Если среда JVM находит цикл, она включает информацию о взаимоблокировке, идентифицирующую, 
    какие блокировки и потоки участвуют, и где в программе нарушен захват блокировки.
    
    Для инициирования сброса дампа потока, можно отправить процессу JVM сигнал SIGQUIT (kill -3) на платформах Unix или 
    нажать комбинацию клавиш Ctrl-\ в Unix или Ctrl-Break на платформах Windows. 
    Многие IDE также могут запросить дамп потока.

гл. 10.1 Взаимоблокировки "Java concurrency in practice" Brian Goetz

https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html

[к оглавлению](#Multithreading)

## 7. Назовите различия между CollectionssynchronizedMap(new HashMap()) и ConcurrentHashMap?

Оба являются синхронизированными версиями HashMap c различиями в функциональности и внутренней структуре. 

SynchronizedMap оборачивает обычный Map используя единственный монитор для блокировки,

тогда как ConcurrentHashMap:
+ позволяет делать неблокирующее чтение (но можно увидеть старые\невалидные данные).
+ на запись делит map на секции, к каждой из которых идет свой объект блокировки (это уменьшает общее время ожидания).

**ConcurrentHashMap** позволяет одновременную модификацию карты из нескольких потоков без необходимости их блокировки.
Операции получения `get` не блокируются, поэтому могут перекрываться с операциями обновления `put` и `remove`.
Считывание происходит очень быстро, в то время как запись выполняется с помощью блокировки. Т.е. несколько потоков 
могут одновременно получить/положить пары key-value из ConcurrentHashMap без блокирования/ожидания друг друга. 

+ На уровне объекта нет блокировки. Блокировка имеет более мелкую детализацию. 
ConcurrentHashMap состоит из внутренних сегментов, которые могут быть заблокированы отдельными потоками, выполняемыми 
одновременно.
+ Эффект блокировки нижнего уровня заключается в том, что одновременно могут быть и читатели и писатели, 
что невозможно для синхронизированных коллекций. Это приводит к гораздо большей масштабируемости.
+ ConcurrentHashMap не бросает ConcurrentModificationException, если один поток пытается изменить его, а другой 
выполняет итерацию по нему. ConcurrentHashMap предоставляет Iterator, который не требует синхронизации, и даже позволяет 
изменять карту во время итерации (но не гарантирует, будут ли возвращены элементы, вставленные во время итерации).
+ ConcurrentHashMap как и Hashtable, в отличие от HashMap, не позволяет использовать `null` в качестве ключа или значения.

**Collections.synchronizedMap(new HashMap())** создает синхронизированную версию HashMap с блокируемым доступом.
Если несколько потоков попытаются получить доступ к synchronizedMap одновременно, то им будет 
разрешено получить/положить по однй паре key-value синхроннизированно. Т.е. пока один поток выполняется, все 
остальные должны ждать, независимо хотят ли они получить или положить данные.

+ Каждый метод синхронизируется с использованием блокировки уровня объекта. 
Таким образом, методы `get` и `put` на synchronizedMap приобретают блокировку.
+ Блокировка всей коллекции снижает производительность, хотя и обеспечивает согласованность (при правильном использовании). 
Пока один поток захватил монитор, ни один другой поток не может использовать коллекцию.
Это не проблема, когда операции вставки или поиска выполняются не интенсивно. 
Однако когда нужно перебирать карту большого размера, это может занять много времени.

гл. 5.2.1 Класс ConcurrentHashMap "Java concurrency in practice" Brian Goetz 

[к оглавлению](#Multithreading)

## 8. Различия в интерфейсах Runnable и Callable?

Runnable не может вернуть результат или бросить Exception, оба — обертки кода для вызова из других потоков.

+ Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки 
`java.util.concurrent`;
+ Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод `run()`. 
Классы, реализующие интерфейс Callable - метод `call()`;
+ Метод `run()` является `void` поэтому ничего не возвращает, а метод `call()` возвращает значение типа `V`. 
Интерфейс `Callable<V>` является параметризованным и тип значения, которое будет возврщаться в 
методе `call()`, задается этим параметром `V`.
+ Метод `run()` не может выбрасывать проверяемые исключения, в то время как метод `call()` может.

https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html

[к оглавлению](#Multithreading)

## 9. Различя между isInterrupted(), interrupted()?

Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. 
Прерывание потока вызовом метода `Thread.interrupt()` устанавливает этот флаг.

Методы `Thread.interrupted()` и `isInterrupted()` позволяют проверить, является ли поток прерванным.

+ Статический метод `Thread.interrupted()` проверяет, был ли установлен флаг прерывания у текущего потока. 
При этом флаг прерывания сбрасывается. Фактически, это еще и ограничивает возможность снять флаг прерывания у 
других тредов (нельзя "украсть" прерывание другого треда). 

+ Нестатический метод `isInterrupted()` проверяет статус прерывания у потока, для которого этот метод был вызван, 
не изменяя флаг состояния (поэтому можно вызывать несколько раз).

[к оглавлению](#Multithreading)

## 10. Что происходит при вызове Threadinterrupt()?

вызов `Thread.interrupt()` устанавливает флаг прерывания потока, либо

+ если поток заблокирован на мониторе, ждет другой поток итп (wait, notify) — вылетит InterruptedException, 
но флаг interrupted потока не поставится.
+ если поток ждет ввод-вывод на InterruptableChannel то тоже вылетит exception.
+ если поток ждет ввод-вывод, то он тут же прекратится и выставится флаг Interrupted.

[к оглавлению](#Multithreading)

## 11. Перечислите ВСЕ причины по которым может выскочить InterruptedException?

Поток ждет в `wait()`, `sleep(…)`, `join()` или заблокирован на длительное время аналогичным вызовом.. 
и из соседнего потока дернули `interrupt()`.

+ Поток прерван во время ожидания на мониторе
+ Поток прерван во время засыпания
+ Поток прерван во время захвата `ReentrantLock` через `lockInterruptibly`
+ Поток прерван во время ожидания в `CountDownLatch` через `await`
+ Поток прерван во время ожидания в `CyclicBarrier` через `await`
+ Поток прерван во время ожидания в `Condition` через `await`
+ Поток прерван во время захвата попытки в `Semaphore` через `acquireUninterruptibly`
+ Поток прерван во время получения значения в `Future` через `get`
+ Поток прерван во время обмена значенимя в `Exchanger` через `exchange`
+ Поток прерван во время блокирующих операций с `BlockingQueue`
+ Поток прерван во время работы с I/O через `InterruptableChannel`

В общем, почти любой блокирующий метод выбрасывает это исключение.

https://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html

[к оглавлению](#Multithreading)

## 12. Назовите отличия synchronize{} и ReentrantLock?

+ `synchronize` — более примитивная конструкция, которая обязывает нас отпустить monitor по окончании секции. 
Таким образом захват\освобождение всегда идут парами и всегда связаны с некоторым блоком кода.
+ `ReentrantLock` — можно захватывать и освобождать мониторы в произвольном порядке, дает гибкость но сложнее сделать 
все правильно. Также есть опция fair — следить ли за «честным» порядком предоставления доступа\времени ожидания 
потоков на мониторе.
+ `ReentrantLock` — лучше масштабируется при росте числа потоков.

В Java 5 появился интерфейс Lock, предоставляющий возможности более эффективного и тонкого контроля блокировки ресурсов.
  
**`ReentrantLock`** – реализация интерфейса Lock с таким же базовым поведением и семантикой, как у synchronized, 
но с расширенными возможностями, такими как опрос о блокировании (lock polling), ожидание блокирования 
заданной длительности и прерываемое ожидание блокировки. Кроме того, он предлагает гораздо более высокую эффективность 
функционирования в условиях жесткой состязательности.

**Блокировка с повторным входом (reentrant)** означает, что есть подсчет сбора данных, связанный с блокировкой, и 
если поток, удерживающий блокировку, снова ее получает, данные отражают увеличение, и тогда для реального 
разблокирования нужно два раза снять блокировку. 

**reentrancy** означает возможность повторного захвата монитора, владельцем которого текущий поток уже является. 
Сильно упрощает код и позволяет делать рекурсивные вызовы, легче избежать deadlock’a.

Это аналогично семантике synchronized: если поток входит в синхронный блок, защищенный монитором, 
который уже принадлежит потоку, то потоку будет разрешено дальнейшее функционирование, и блокировка не будет снята. 
Когда поток выйдет из второго (или последующего) блока synchronized, она будет снята только 
когда он выйдет из первого блока synchronized, в который он вошел под защитой монитора.

```java
    Lock lock = new ReentrantLock();

    lock.lock();
    try { 
        // update object state
    }
    finally {
        lock.unlock(); 
    }
```

+ Реализация ReentrantLock гораздо более масштабируема в условиях состязательности, чем реализация synchronized. 
Это значит, что когда много потоков соперничают за право получения блокировки, общая пропускная способность лучше 
у ReentrantLock, чем у synchronized. JVM требуется меньше времени на установление очередности потоков и 
больше времени на непосредственно выполнение.
+ У ReentrantLock (как и у других реализаций Lock) блокировка должна обязательно сниматься в finally блоке (иначе, если 
защищенный код выбросит исключение, блокировка не будет снята). Используя синхронизацию, JVM гарантирует, что 
блокировка автоматически снимаются.

Вывод: когда состязания за блокировку нет или оно очень мало, то `synchronized` возможно будет быстрее. 
Если присутствует заметное состязание за доступ к ресурсу, то `ReentrantLock` дает преимущество.

https://netjs.blogspot.com/2016/02/difference-between-reentrantlock-and-synchronized-java.html

гл. 13.4 Выбор между synchronized и ReentrantLock "Java concurrency in practice" Brian Goetz

https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html

[к оглавлению](#Multithreading)

## 13. Приведите наиболее существенное отличие между CountDownLatch и Barrier?



[к оглавлению](#Multithreading)

## 14. Отличие Threadstart() и Threadrun()?

`Thread.start()` порождает новый поток, в котором исполняет код `Thread.run()`, т.е.
+ `start()` — стартует нитку.
+ `run()` — стартует код в текущей нитке без порождения отдельного потока.

`Thread.start()` в отличие от `Thread.run()` переводит поток в состояние RUNNABLE и запускает код независимо от текущего потока. 
В случае же вызова `Thread.run()` код выполнит тот же поток, который вызвал этот метод. 

Семантика этих методов совершенно разная: `run()` отвечает за задачу, которую нужно выполнить независимо, 
а `start()` поднимает инфрастуктуру по выполнению этой задачи.

[к оглавлению](#Multithreading)

## 15. Объясните ключевое слово volatile?

Модификатор `volatile` указывает на то, что поле синхронизировано для нескольких потоков.
```java
private volatile boolean varName; //синтаксис
```

Модификатор `volatile` вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной.
*Запись* volatile-переменных производится в основную память (медленную), минуя локальную (кэш). 
*Чтение* volatile-переменной производится также из основной памяти, т.e. значение переменной не может 
сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт 
последнее записанное в неё значение.
Поэтому `volatile` дает гарантии happens-before на все присвоения переменных до текущего момента 
(так называемый read memory barrier).

Внимание!
+ Если переменная примитивного типа, то этого будет достаточно для обеспечения потокобезопасности. 
+ Если переменная является ссылкой на объект, то синхронизировано будет исключительно значение этой ссылки. 
Все же данные, содержащиеся в объекте, синхронизированы не будут.

[к оглавлению](#Multithreading)

## 16. Расскажите про приоритеты потока?



[к оглавлению](#Multithreading)

## 17. Что такое потоки демоны?



[к оглавлению](#Multithreading)

## 18. Назовите все возможные состояния потока?



[к оглавлению](#Multithreading)

## 19. Что такое race condition?



[к оглавлению](#Multithreading)

## 20. Что такое Thread Local переменная?



[к оглавлению](#Multithreading)

## 21. Что такое FutureTask?



[к оглавлению](#Multithreading)

## 22. Что такое Thread Pool?



[к оглавлению](#Multithreading)

## 23. Что такое Semaphore?

`Semaphore` – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор. 
Доступ управляется с помощью счётчика: изначальное значение счётчика задаётся в конструкторе при создании синхронизатора, 
когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, 
когда поток его покидает, то увеличивается. 
Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. 

`Semaphore` используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например 
подключение к базе данных в пуле.

гл. 5.5.3 Семафоры "Java concurrency in practice" Brian Goetz

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html

[к оглавлению](#Multithreading)

## 24. Чем отличается submit от execute у ExecutorServices?



[к оглавлению](#Multithreading)

## 25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?



[к оглавлению](#Multithreading)

## 26. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков?



[к оглавлению](#Multithreading)

## 27. Что такое ReadWriteLock?



[к оглавлению](#Multithreading)

## 28. В чём отличие Thread от FutureTask В чём отличие Threadinterrupt() и FutureTaskcancel()?



[к оглавлению](#Multithreading)

## 29. Расскажите про шаблон проектирования Producer Consumer?



[к оглавлению](#Multithreading)

## 30. ?



[к оглавлению](#Multithreading)

