## Garbage Collection

[1. Чем java отличается от с++?](#1-Чем-java-отличается-от-с)

[2. Что такое менеджер памяти?](#2-Что-такое-менеджер-памяти)

[3. Какой механизм используется в Java для управления памятью?](#3-Какой-механизм-используется-в-Java-для-управления-памятью)

[4. Опишите процесс работы сборщика мусора?](#4-Опишите-процесс-работы-сборщика-мусора)

[5. Какие алгоритмы сборщика вы знаете?](#5-Какие-алгоритмы-сборщика-вы-знаете)

[6. Чем отличаются сборщики мусора?](#6-Чем-отличаются-сборщики-мусора)

[7. Расскажите про утилиты для анализа памяти?](#7-Расскажите-про-утилиты-для-анализа-памяти)

[8. Что такое ссылки?](#8-Что-такое-ссылки)

[9. Какие типы ссылок вы знаете?](#9-Какие-типы-ссылок-вы-знаете)

[10. Чем они отличаются?](#10-Чем-они-отличаются)

## 1. Чем java отличается от с++?

В C++ выделение и освобождение памяти - это ручной процесс (например, с помощью операторов new и delete). 

В Java процесс освобождения памяти автоматически обрабатывается сборщиком мусора. 
(освобождает память в куче, занятой неиспользуемыми объектами)

Т.е. в отличие от С++ нет явной необходимости уничтожать объект. 

[к оглавлению](#garbage-collection)

## 2 Что такое менеджер памяти?

Менеджер памяти — часть компьютерной программы (как прикладной, так и операционной системы), 
обрабатывающая запросы на выделение и освобождение оперативной памяти 
или (для некоторых архитектур ЭВМ) запросы на включение заданной области памяти в адресное пространство процессора.

Основное назначение менеджера памяти в первом смысле — реализация динамической памяти, т.е. 
выделение оперативной памяти компьютера для объектов в программе осуществляется во время ее выполнения.

Менеджеры памяти часто образуют иерархию, т.е. нижестоящие менеджеры задействуют какие-либо закономерности выделения-освобождения 
памяти и этим снижают нагрузку на вышестоящие. Например:

+ Системный - менеджер памяти, встроенный в ОС.
+ Принадлежащий процессу - менеджер памяти, встроенный в стандартную библиотеку языка программирования, 
берёт у ОС блоки памяти «оптом» и раздаёт их сообразно с нуждами программиста.
+ Специализированные - некоторые динамические структуры данных, например, vector, 
также берут память у стандартной библиотеки с запасом (обычно, блоками экспоненциально увеличивающегося размера). 

Подобная иерархия приводит к тому, что на каждом из уровней «залёживается» свободная память. 
Но это оправдано: снижается фрагментация памяти и повышается скорость.

[к оглавлению](#garbage-collection)

## 3 Какой механизм используется в Java для управления памятью?

Распределение памяти в java реализует технология Java HotSpot от Oracle. Она обеспечивает выделение памяти для объектов и сборщиков мусора.


[к оглавлению](#garbage-collection)

## 4 Опишите процесс работы сборщика мусора?



[к оглавлению](#garbage-collection)

## 5 Какие алгоритмы сборщика вы знаете?

Сборщик мусора имеет несколько алгоритмов очистки памяти. В первую очередь, он может быть вызван, 
когда объем свободной памяти в области Eden Space становится критичным. В этом случае, Garbage Collector просто 
переносит объекты, имеющие ссылки, из области Eden Space в область Survivor Space, а объекты без ссылок удаляет. 
Эта, так называемая minor'ная очистка, выполняется быстро.

Если при очистке мусора памяти в области Survivor Space недостаточно, то долгоживущие объекты переносятся 
в область Tenured Generation, где они могут хранится до конца работы приложения. Вся остальная куча очищается от мусора.

Следует отметить, что сборщик мусора периодически вызывается виртуальной машиной, а не только тогда, когда не хватает памяти.

[к оглавлению](#garbage-collection)

## 6 Чем отличаются сборщики мусора?

**Serial (последовательный)** — самый простой вариант для приложений, 
которым не требуется большой размер кучи для работы (Oracle указывает условную границу 100 МБ), 
которые не очень чувствительны к коротким остановкам и им для работы доступно только одно ядро процессора.
Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.

**+** Непритязательность по части ресурсов компьютера. Т.к. всю работу он выполняет последовательно в одном потоке, никаких заметных оверхедов и негативных побочных эффектов у него нет.

**-** Долгие паузы на сборку мусора при заметных объемах данных. 

**-** Все настройки Serial GC крутятся вокруг размеров различных регионов кучи, т.е. для тонкой настройки 
требуется вручную что-то изучать, настраивать, экспериментировать и т.д. 

**Parallel (параллельный)** — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в 
некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.
В целом, Parallel GC — это простой, понятный и эффективный сборщик, подходящий для большинства приложений. 
У него нет скрытых накладных расходов, мы всегда можем поменять его настройки и ясно увидеть результат этих изменений.

**+** в сравнении с Serial GC есть возможность автоматической подстройки под требуемые параметры производительности 
и меньшие паузы на время cборок. При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех приложениях.

**-** Определенная фрагментация памяти, но вряд ли она будет существенной для большинства приложений, 
т.к. сборщиком используется относительно небольшое количество потоков.

**Concurrent Mark Sweep (CMS)** — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора 
параллельно с основными потоками приложения. Более требователен к ресурсам процессора.
Подходит для работы в приложениях с относительно большими объемами долгоживущих данных,
для приложений, имеющих доступ к нескольким ядрам процессора и чувствительных к паузам STW.

**+** по сравнению с рассмотренными ранее Serial/Parallel GC ориентирован на минимизацию времени простоя, 
что является критическим фактором для многих приложений. 
Но для выполнения этой задачи приходится жертвовать ресурсами процессора и зачастую общей пропускной способностью.

**-** не уплотняет объекты в старшем поколении, что приводит к фрагментации Tenured. 
Этот факт в совокупности с наличием плавающего мусора приводит к необходимости выделять приложению 
(конкретно — старшему поколению) больше памяти, чем потребовалось бы для других сборщиков (Oracle советует на 20% больше).

**-** долгие паузы при потенциально возможных сбоях конкурентного режима могут стать неприятным сюрпризом. 
Хотя они не частые, и при наличии достаточного объема памяти CMS’у удается их полностью избегать.

**Garbage-First (G1)** — создан для замены CMS, но не является явным продолжением линейки Serial/Parallel/CMS. 
Мспользуется в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных (размер кучи от 4 ГБ и выше), 
для которых важно сохранять время отклика небольшим и предсказуемым, пусть даже за счет уменьшения пропускной способности.

**+** G1 более точно предсказывает размеры пауз, чем CMS, и лучше распределяет сборки во времени, 
чтобы не допустить длительных остановок приложения, особенно при больших размерах кучи. 

**+** В отличие от CMS, например, он не фрагментирует память.

**-** Тратит ресурсы процессора, которые использует для выполнения достаточно большой части своей работы параллельно с основной программой. 
В результате страдает пропускная способность приложения. 
Целевое значением пропускной способности по умолчанию для G1 равно 90%, для Parallel GC составляет 99%. 
Это не значит, что пропускная способность с G1 всегда будет почти на 10% меньше, но данную особенность следует учитывать.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_6.1.png)
 
«Монолитный» означает то, что всё поколение должно быть очищено за проход.

«В большинстве случаев одновременный» — mostly concurrent, одновременный имеется в виду фоновый, «работающий вместе с потоками приложения».

Подробнее здесь https://habr.com/ru/post/269621/

[к оглавлению](#garbage-collection)

## 7 Расскажите про утилиты для анализа памяти?

встроенные в JDK утилиты: jps, jmap, jstat, jconsole, visualvm до java 9.

внешние: VisualVM c java 9 и утилита от NetBeans - YourKit Java Profiler .

jconsole, visualvm, yourkit profiler предоставляют удобный визуальный интерфейс.

**jps** - выводит pid-ы процессов, которые использует VM

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.1.png)

 
**jmap** - выводит информацию о состоянии памяти виртуальной машины
	jmap -heap 14152
	или jhsdb jmap --heap --pid 14152
	
![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.2.png)
 
**jstat** аналогично jmap
jstack - показывает какие процессы запущены в  виртуальной машине (нет инфы о памяти)

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.3.png)
 
...

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.4.png) 

**jconsole**
 
![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.5.png) 

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.6.png)

**VisualVM** (с плагином VisualGC)

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.7.png) 

**YourKit Profiler** - универсальный расширенный профилировщик, используется не только для анализа памяти, 
но и ,например, для поиска узких мест в коде (повторения и тп)

[к оглавлению](#garbage-collection)

## 8 Что такое ссылки?



[к оглавлению](#garbage-collection)

## 9 Какие типы ссылок вы знаете?



[к оглавлению](#garbage-collection)

## 10 Чем они отличаются?



[к оглавлению](#garbage-collection)

## Источники:

**Описание распределения памяти в JVM, принципы работы и виды GC** 

http://java-online.ru/java-interview-05.xhtml

https://habr.com/ru/post/269621/
